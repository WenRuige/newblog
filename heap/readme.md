#### `heap`

堆的经典实现是完全二叉树(`complete binary tree`),这样实现的堆称为二叉堆(`binary heap`)

需要满足两个性质
* 完全二叉树
* 每个节点的值都小于/大于它的子节点

##### 大顶堆&小顶堆
* 大顶堆:每个节点的值都大于等于其左右孩子节点的值,称为大顶堆
* 小顶堆:每个节点的值都小于其左右孩子节点的值,称为小顶堆



在程序设计领域,堆的概念主要涉及到两个方面:
* 一种数据结构,逻辑上是一颗完全二叉树,存储是一个数组对象(二叉堆)
* 垃圾收集存储区,是软件系统可以编程的内存区域


堆排序的时间复杂度是`O(nlgn)`,与快速排序达到相同的时间复杂度,但是在实际应用中,往往采用快速排序,而不是堆排序


> 堆排序的主要用途

计算要求是类优先级队列(比如只返回,最大或者最小元素)

##### 堆的基本操作
构造有序堆的时候,只需要扫描一半的数据(`n/2 - 1`)即可

> 为什么扫描一半的数据?

编号为i的父节点为:因为(`n/2 - 1 ~ 0`)的节点才有子节点   
1
左节点为: 2 * i + 1
 
右节点为: 2 * i + 2


向下调整代码:
```
void siftdown(int i){    //传入一个需要向下调整的节点编号i,这里传入1,既从堆的顶点开始向下调整
    int t,flag =0;  //flag用来标记是否需要继续向下调整
    //当i节点有儿子的时候(至少有左儿子的情况下)并且有需要继续调整的时候循环执行
    while(i*2 <= n && flag ==0){
        //首先判断他和他左儿子的关系,并用t记录值较小的节点编号
        if(h[i] > h[i*2]){  // 如果大于它的左儿子
            t = i * 2       // 记录当前节点为左儿子节点
        }else{
            t = i           // 记录当前节点为它自己
        }
        // 如果他有右儿子,
        if(i*2 +1 <= n){
               // 如果右儿子值更小,更新较小的编号节点
            if(h[t] > h[i*2 +1]){
                 t = i *2 +1
            }
        }
        // 如果发现最小的节点编号不是他自己,说明子节点中有比父节点更小的
        if (t != i){
            swap(t,i)  //交换他们,swap需要自己来写
            i = t    
        }else{
            flag = 1
        }
    }
}

```








